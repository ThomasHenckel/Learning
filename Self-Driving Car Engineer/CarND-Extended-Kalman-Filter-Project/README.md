# **Extended Kalman Filter Project**

Self-Driving Car Engineer Nanodegree Program

[//]: # (Image References)
[image1]: ./images/simulator_run1.gif "run1"

This project utilizes a Kalman filter to estimate the state of a moving object of interest with noisy lidar and radar measurements.

lidar and radar input are generated by the [simulator](https://github.com/udacity/self-driving-car-sim/releases), and the predicted location of the object is calculated and send back to the simulator. The simulator has two datasets, below is seen a run of the car using dataset 1.

![alt text][image1]

Red and blue dots are radar and lidar measurements, and the green dots are the predicted location.
for each run the root mean square error were calculated, these can be seen in the table below

 Dataset |px | py | vx | vy
:------:|:-:|:--:|:--:|:--:
Dataset 1  | 0.1073 | 0.0954 | 0.4769 | 0.4897
Dataset 2  | 0.0771 | 0.1129 | 0.4425 | 0.5727

To run the project start the simulator and select "EKF and UKF" then run the compiled project from /build using ´./ExtendedKF´

Setup and compilation instructions can be found in [https://github.com/udacity/CarND-Extended-Kalman-Filter-Project](https://github.com/udacity/CarND-Extended-Kalman-Filter-Project)

## Code walkthrough

`main.cpp` connects and gets measurements from the simulator, it creates an instance of fusionEKF, the measurements are send to fusionEKF and predictions are returned, the measurements and predictions are stored, and for each iteration these are compared using tools.CalculateRMSE()

`fusionEKF.cpp` has a constructor that initializes some of the Kalman filter matrices, first time it is called with a measurement it will initialize its location (px,py) as the velocity is not known from one location, the velocity is set to 0.
For each measurement after initialization the predict and update functions will be called, these functions are found in kalman_filter.cpp

`kalman_filter.cpp` contains the predict function that is common for both the radar and lidar measurements, and an update function for laser measurements and one for radar measurements.
The laser measurements comes in the form (px,pv,vx,vy) and can be parsed directly to the update function. The radar measurements on the other hand is in the form (range, angle, and range_dot) as these values are nonlinear, and the Kalman filter operates on linear measurements we need to approximate a linear function for the radar measurements, this is done in Tools.CalculateJacobian(). this function will calculate Hj that will be used in the update step instead of H. In the update step we also need to take the coordinates from the prediction step in (px,pv,vx,vy) and calculate it into the form (range,angle, range_dot) to be able to calculate the prediction error y.

`tools.cpp` has to helper functions CalculateJacobian() that calculates the Jacobian matrix for the radar measurements and CalculateRMSE that calculates the Running Mean Square Error

